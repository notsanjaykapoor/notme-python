#!/usr/local/bin/python3

from dotenv import load_dotenv

load_dotenv() # take environment variables from .env.

from database import engine
from sqlmodel import Session, SQLModel
from typing import Optional

import asyncio
import json
import logging
import time
import typer
import ulid
import uvloop
import websocket

from actors.example.app import App
from actors.handlers.generic import HandlerGeneric as ActorHandler

from kafka.handlers.generic import HandlerGeneric as KafkaHandler
from kafka.reader import KafkaReader
from kafka.writer import KafkaWriter

from log import logging_init
from models import user

from services.crypto.pkey.create import PkeyCreate
from services.crypto.pkey.sign import PkeySign
from services.crypto.pkey.verify import PkeyVerify
from services.crypto.symmetric.decrypt import SymmetricDecrypt
from services.crypto.symmetric.encrypt import SymmetricEncrypt
from services.crypto.symmetric.create import SymmetricCreate
from services.users.create import UserCreate
from services.users.get import UserGet
from services.users.list import UsersList

logger = logging_init("cli")

app = typer.Typer()

@app.command()
def actor_client(topic: str = typer.Option(...)):
  writer = KafkaWriter(topic=topic)

  file = f"{topic}.json" # e.g. example.json
  data = json.load(open(file))

  for record in data:
    # write to kafka stream
    writer.call(
      key = ulid.new().str,
      message = record,
    )

    break

@app.command()
def actor_server(app: str = typer.Option(...), msg: str = "ping"):
  uvloop.install()
  asyncio.run(actor_server_async(app=app, msg=msg))

async def actor_server_async(app: str, msg: str):
  logger.info(f"cli actor_server")

  # start app
  struct_app = App(toml_file=f"./data/apps/{app}.toml").call()

  while True:
    await asyncio.sleep(1)

  # get app tasks
  # tasks = [actor.task for name, actor in struct_app.actors.items()]

  # wait on tasks
  # logger.info(f"cli actor_server waiting on {len(tasks)} tasks")
  # await asyncio.gather(*tasks)

  # actor_source = struct_manager.actors["source"]
  #
  # message = {
  #   "message": msg,
  # }
  #
  # r = range(5)
  #
  # for i in r:
  #   await asyncio.sleep(3)
  #
  #   message["index"] = i
  #   message["rid"] = ulid.new().str
  #
  #   actor_source.queue.put_nowait(message)

@app.command()
def crypto_sign(data: str = "secret"):
  struct_pkey = PkeyCreate().call()

  private_key = struct_pkey.key
  public_key = private_key.public_key()

  struct_sign = PkeySign(
    private_key,
    data
  ).call()

  logger.info(f"cli sign {struct_sign}")

  signature = struct_sign.encoded

  struct_verify = PkeyVerify(
    public_key,
    data,
    signature,
  ).call()

  logger.info(f"cli verify {struct_verify}")

@app.command()
def crypto_symmetric(data: str = "a secret message"):
  # note: data must be multiple of 16 bytes

  struct_symmetric = SymmetricCreate().call()

  cipher = struct_symmetric.cipher

  struct_encrypt = SymmetricEncrypt(
    cipher,
    data
  ).call()

  struct_encrypt = SymmetricDecrypt(
    cipher,
    struct_encrypt.encoded,
  ).call()

@app.command()
def json_read(file: str = "entities.json"):
  data = json.load(
    open(file)
  )

  for record in data:
    logger.info(f"record {record}")

@app.command()
def topic_read(topic: str = typer.Option(...), group: str="python"):
  # call reader with generic handler
  handler = KafkaHandler()
  reader = KafkaReader(topic, group, handler)
  reader.call()

@app.command()
def topic_write(topic: str = typer.Option(...), key: str = typer.Option(...)):
  # todo: use async?

  writer = KafkaWriter(topic=topic)

  writer.call(
    key=key,
    message={
      "message": "ping",
      "rid": ulid.new().str,
    }
  )

@app.command()
def user_create(name: str = typer.Option(...)):
  logger.info(f"cli user {name} create try")

  with Session(engine) as db_session:
    user = UserGet(db_session, name).call()

    if user:
      log.info(f"cli result user {name} exists")
      return 0

    user_id = UserCreate(session, name).call()

    log.info(f"cli result user {name} created")

    return user_id

@app.command()
def user_search(query: str = ""):
  with Session(engine) as db_session:
    service = UsersList(db_session, query, 0, 10)
    struct = service.call()

    for user in struct.users:
      logger.info(f"cli result {user}")

@app.command()
def ws_send(message: str = "hey"):
  logger.info(f"cli websocket sending '{message}'")

  ws = websocket.WebSocket()
  ws.connect("ws://localhost:8000/ws")
  ws.send(message)
  ws.close()

if __name__ == "__main__":
  app()
